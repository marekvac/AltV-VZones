using System.Numerics;
using System.Text.Json.Serialization;
using AltV.Net;
using MarcusCZ.AltV.VZones.Shared.Structs;
using MarcusCZ.AltV.VZones.Shared.Util;

namespace MarcusCZ.AltV.VZones.Shared;

public abstract class SharedZone3 : IZone
{
    public string Type => GetType().Name;
    public List<Vector2> Points { get; set; }
    public string Name { get; set; }
    public float Z { get; set; }
    public float Height { get; set; }
    private Vector3? _center;
    [JsonIgnore]
    public Vector3 Center
    {
        get
        {
            if (!_center.HasValue) _center = GetCenter();
            return _center.Value;
        }
    }
    
    public bool Active { get; set; }

    public abstract IMValueBaseAdapter GetAdapter();

    protected SharedZone3()
    {
    }

    protected SharedZone3(string name, Vector3 center)
    {
        Name = name;
        Points = new List<Vector2>();
        Height = 10;
        Z = center.Z;
        Vector2 center2d = VectorUtils.AsVector2(center);
        Points.Add(center2d + Vector2.UnitX + Vector2.UnitY);
        Points.Add(center2d + Vector2.UnitX - Vector2.UnitY);
        Points.Add(center2d - Vector2.UnitX - Vector2.UnitY);
        Points.Add(center2d - Vector2.UnitX + Vector2.UnitY);
    }

    protected SharedZone3(string name, float z, float height, List<Vector2> points)
    {
        Name = name;
        Z = z;
        Height = height;
        Points = points;
        Active = true;
    }

    public List<Vector3> GetPoints3D()
    {
        float z = Z;
        return Points.Select(p => new Vector3(p, z)).ToList();
    }

    public void Move(Vector3 direction)
    {
        Z += direction.Z;
        Vector2 dir2d = VectorUtils.AsVector2(direction);
        lock (Points)
        {
           Points = Points.Select(p => p + dir2d).ToList();
        }
    }

    public void Rotate(float angle)
    {
        var angleInRadians = angle * Math.PI / 180;
        var center = GetCenter();
        float cos = (float) Math.Cos(angleInRadians);
        float sin = (float) Math.Sin(angleInRadians);

        lock (Points)
        {
            Points = Points.Select(p =>
            {
                var x = p.X - center.X;
                var y = p.Y - center.Y;
                p.X = x * cos - y * sin + center.X;
                p.Y = x * sin + y * cos + center.Y;
                return p;
            }).ToList();
        }
    }

    public bool IsInside(Vector3 point)
    {
        if (point.Z > Z + Height || point.Z < Z)
        {
            return false;
        }
        
        // Raycast generated by AI
        var crossingNumber = 0;
        
        for (int i = 0; i < Points.Count; i++)
        {
            var p1 = Points[i];
            var p2 = Points[(i + 1) % Points.Count];

            if (p1.Y > point.Y != p2.Y > point.Y &&
                point.X < (p2.X - p1.X) * (point.Y - p1.Y) / (p2.Y - p1.Y) + p1.X)
            {
                crossingNumber++;
            }
        }

        return crossingNumber % 2 == 1;
    }

    public Vector3 GetCenter()
    {
        float x = Points.Select(vector2 => vector2.X).Sum() / Points.Count;
        float y = Points.Select(vector2 => vector2.Y).Sum() / Points.Count;
        return new Vector3(x, y, Z + Height / 2);
    }

    public void ReloadCenter()
    {
        lock(Points)
        {
            _center = GetCenter();
        }
    }
    
    public void MoveWall(int index, Vector2 direction2d)
    {
        lock (Points)
        {
            Points[index] += direction2d;
            if (index >= Points.Count -1) Points[0] += direction2d;
            else Points[index + 1] += direction2d;
        }
    }
    
    public void MovePoint(int index, Vector2 direction2d)
    {
        lock (Points)
        {
            Points[index] += direction2d;
        }
    }

    public void MoveTop(float z)
    {
        if (Height + z < 0.005) return;
        Height += z;
    }
    
    public void MoveBottom(float z)
    {
        Z += z;
    }

    public Line2? GetClosestSide(Vector3 point, float maxDistance = float.MaxValue)
    {
        Vector2 point2d = VectorUtils.AsVector2(point);
        List<Vector2> points = Points
            .Select(p => new Tuple<Vector2,float>(p, Vector2.Distance(p, point2d)))
            .Where(tuple => tuple.Item2 <= maxDistance)
            .OrderBy(tuple => tuple.Item2)
            .Select(tuple => tuple.Item1).Take(2).ToList();
        
        if (points.Count < 2) return null;
        
        return new Line2(points[0], points[1]);
    }

    public List<Line2> GetAllSides(Vector3 origin, float maxDistance)
    {
        List<Line2> sides = new ();
        Vector2 point2d = VectorUtils.AsVector2(origin);
        for (int i = 0; i < Points.Count; i++)
        {
            var p1 = Points[i];
            var p2 = Points[(i + 1) % Points.Count];
            sides.Add(new Line2(p1, p2));
        }

        sides = sides.Select(s => new Tuple<Line2, float>(s, Vector2.Distance(s.GetCenter(), point2d)))
            .Where(tuple => tuple.Item2 < maxDistance)
            .OrderBy(tuple => tuple.Item2)
            .Select(tuple => tuple.Item1).ToList();

        return sides;
    }

    public override string ToString()
    {
        return $"{nameof(Points)}: [{string.Join(", ", Points.Select(p => p.ToString()))}], {nameof(Name)}: {Name}, {nameof(Z)}: {Z}, {nameof(Height)}: {Height}, {nameof(Center)}: {Center}, {nameof(Active)}: {Active}";
    }
}